C51 COMPILER V9.59.0.0   HYBSCH                                                            05/30/2021 22:35:44 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE HYBSCH
OBJECT MODULE PLACED IN .\OutHex\HybSCH.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sources\HybSCH.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\HybSCH.lst) TABS(2) OBJECT(.\OutHex\HybSCH.obj)

line level    source

   1          #include "./Headers/PreMacro.h"
   2          #include "./Headers/HybSCH.h"
   3          
   4          //调度器错误代码
   5          static u8 hsch_error_code;
   6          static u8 last_error_code;
   7          
   8          //错误代码输出超时
   9          static u16 error_tick_count;
  10          
  11          /**
  12           * 任务结构体
  13           * @field func   任务函数
  14           * @field delay  初次执行延时
  15           * @field period 执行周期间隔
  16           * @field co_cp  合作/抢占标志
  17           *               合作：1
  18           *               抢占：0
  19           */
  20          typedef xdata struct
  21          {
  22              Action func;
  23              u16 delay;
  24              u16 period;
  25              u8 runme;
  26              u8 co_cp;
  27              void idata *param;
  28          } hsTask;
  29          
  30          //任务集合
  31          hsTask hsch_tasks[SCH_MAX_TASKS];
  32          
  33          /**
  34           * 使单片机进入休眠
  35           */
  36          void hsch_to_sleep(void);
  37          
  38          /**
  39           * 扫描任务集合并执行
  40           */
  41          void hsch_dispatch_tasks(void)
  42          {
  43   1          u8 i = 0;
  44   1          for (i = 0; i < SCH_MAX_TASKS; i += 1)
  45   1          {
  46   2              if (hsch_tasks[i].runme > 0 && hsch_tasks[i].co_cp && hsch_tasks[i].func != NULL)
  47   2              {
  48   3                  hsch_tasks[i].func(hsch_tasks[i].param);
  49   3                  hsch_tasks[i].runme -= 1;
  50   3      
  51   3                  // 注销一次性函数
  52   3                  if (hsch_tasks[i].period == 0 && hsch_tasks[i].runme == 0)
  53   3                  {
  54   4                      hsch_delete_task(i);
C51 COMPILER V9.59.0.0   HYBSCH                                                            05/30/2021 22:35:44 PAGE 2   

  55   4                  }
  56   3              }
  57   2          }
  58   1          hsch_report_status();
  59   1          hsch_to_sleep();
  60   1      }
  61          
  62          /**
  63           * 添加任务
  64           * @param  func   任务函数
  65           * @param  delay  首次执行延时
  66           * @param  param func 入参
  67           * @param  period 周期执行间隔
  68           * @param  co_cp  合作/抢占标志
  69           * @return        任务ID [用于删除任务]
  70           */
  71          u8 hsch_add_task(Action func, void *param, u16 delay, u16 period, u8 co_cp)
  72          {
  73   1          u8 i = 0;
  74   1          while ((hsch_tasks[i].func != NULL) && (i < SCH_MAX_TASKS))
  75   1          {
  76   2              i += 1;
  77   2          }
  78   1          if (i == SCH_MAX_TASKS)
  79   1          {
  80   2              hsch_error_code = ERROR_SCH_TOO_MANY_TASKS;
  81   2              return SCH_MAX_TASKS;
  82   2          }
  83   1          hsch_tasks[i].func = func;
  84   1          hsch_tasks[i].delay = delay;
  85   1          hsch_tasks[i].period = period;
  86   1          hsch_tasks[i].co_cp = co_cp;
  87   1          hsch_tasks[i].runme = 0;
  88   1          hsch_tasks[i].param = param;
  89   1          return i;
  90   1      }
  91          
  92          /**
  93           * 添加一个一次性任务
  94           * @param func 回调函数
  95           * @param para 函调函数的入参
  96           * @param co_cp 合作/抢占式
  97           */
  98          u8 hsc_once_task(Action func, void *param, u8 co_cp)
  99          {
 100   1          return hsch_add_task(func, param, 0, 0, co_cp);
 101   1      }
 102          
 103          /**
 104           * 删除任务
 105           * @param  i 任务ID
 106           * @return   删除状态
 107           */
 108          bool hsch_delete_task(const u8 i)
 109          {
 110   1          bool ret_code;
 111   1          if (hsch_tasks[i].func == NULL)
 112   1          {
 113   2              hsch_error_code = ERROR_SCH_CANNOT_DELETE_TASK;
 114   2              ret_code = RETURN_ERROR;
 115   2          }
 116   1          else
C51 COMPILER V9.59.0.0   HYBSCH                                                            05/30/2021 22:35:44 PAGE 3   

 117   1          {
 118   2              ret_code = RETURN_NORMAL;
 119   2          }
 120   1          hsch_tasks[i].func = NULL;
 121   1          hsch_tasks[i].delay = 0;
 122   1          hsch_tasks[i].period = 0;
 123   1          hsch_tasks[i].runme = 0;
 124   1          hsch_tasks[i].param = NULL;
 125   1      
 126   1          return ret_code;
 127   1      }
 128          
 129          /**
 130           * 更新调度器，周期由T2设置
 131           */
 132          void hsch_update(void) interrupt TIMMER2_ITRP
 133          {
 134   1          u8 i = 0;
 135   1          TF2 = 0;
 136   1          for (i = 0; i < SCH_MAX_TASKS; i += 1)
 137   1          {
 138   2              if (hsch_tasks[i].func == NULL)
 139   2              {
 140   3                  continue;
 141   3              }
 142   2              if (hsch_tasks[i].delay > 0)
 143   2              {
 144   3                  hsch_tasks[i].delay -= 1;
 145   3                  continue;
 146   3              }
 147   2              //若是合作式则在中断中只置位,等待到hsch_dispatch_tasks中去执行
 148   2              if (hsch_tasks[i].co_cp)
 149   2              {
 150   3                  ++hsch_tasks[i].runme;
 151   3              } // 抢占式任务直接执行
 152   2              else
 153   2              {
 154   3                  hsch_tasks[i].func(hsch_tasks[i].param);
 155   3                  if (hsch_tasks[i].period == 0)
 156   3                  {
 157   4                      hsch_delete_task(i);
 158   4                  }
 159   3              }
 160   2              //如果是周期执行则将周期间隔赋予下次执行的延时
 161   2              if (hsch_tasks[i].period > 0)
 162   2              {
 163   3                  hsch_tasks[i].delay = hsch_tasks[i].period;
 164   3              }
 165   2          }
 166   1      }
 167          
 168          /**
 169           * 用Timmer2作为调度器的时钟源,默认1ms为周期
 170           */
 171          void hsch_init_timmer2(void)
 172          {
 173   1          u8 i = 0;
 174   1          for (i = 0; i < SCH_MAX_TASKS; i += 1)
 175   1          {
 176   2              hsch_delete_task(i);
 177   2          }
 178   1          hsch_error_code = 0;
C51 COMPILER V9.59.0.0   HYBSCH                                                            05/30/2021 22:35:44 PAGE 4   

 179   1      
 180   1          T2CON = 0x04;
 181   1          T2MOD = 0x00;
 182   1          TH2 = 0xfc;
 183   1          RCAP2H = 0xfc;
 184   1          TL2 = 0x18;
 185   1          RCAP2L = 0x18;
 186   1          ET2 = 1;
 187   1          TR2 = 1;
 188   1      }
 189          
 190          /**
 191           * 单片机开启休眠
 192           */
 193          void hsch_to_sleep(void)
 194          {
 195   1          PCON |= 0x01;
 196   1      }
 197          
 198          /**
 199           * 启动调度器
 200           */
 201          void hsch_start(void)
 202          {
 203   1          EA = 1;
 204   1      }
 205          
 206          /**
 207           * 输出调度器状态
 208           */
 209          void hsch_report_status(void)
 210          {
 211   1      #ifdef SCH_REPORT_STATUS
                  if (hsch_error_code != last_error_code)
                  {
                      ERROR_PORT = 0xff - hsch_error_code;
                      last_error_code = hsch_error_code;
                      if (hsch_error_code != 0)
                      {
                          error_tick_count = 6000;
                      }
                      else
                      {
                          error_tick_count = 0;
                      }
                  }
                  else
                  {
                      if (error_tick_count != 0)
                      {
                          if (--error_tick_count == 0)
                          {
                              hsch_error_code = 0;
                          }
                      }
                  }
              #endif
 236   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    884    ----
C51 COMPILER V9.59.0.0   HYBSCH                                                            05/30/2021 22:35:44 PAGE 5   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     36    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
